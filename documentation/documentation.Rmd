---
author:
  - name: Anna Michalek
    affiliation: European Central Bank
    email: \email{anna.michalek@ecb.int}
  - name: Alain Quartier-La-Tente
    affiliation: Insee
    email: \email{alain.quartier@gmail.com}
title:
  formatted: "\\pkg{RJDemetra}: A R Interface To JDemetra+ Seasonal Adjustment Software"
  # If you use tex in the formatted title, also supply version without
  plain:     "A Capitalized Title: Something about a Package foo"
  # For running headers, if needed
  short:     "\\pkg{RJDemetra}: A R Interface To JDemetra+ Seasonal Adjustment Software"
abstract: >
  The abstract of the article.
keywords:
  # at least one keyword must be supplied
  formatted: ["\\proglang{R}", seasonal adjustment, time series]
  plain:     [R, seasonal adjustment, time series]
preamble: >
  \usepackage{amsmath}
  \usepackage{booktabs}
  \usepackage{longtable}
  \usepackage{array}
  \usepackage{multirow}
  \usepackage{wrapfig}
  \usepackage{float}
  \usepackage{pdflscape}
  \usepackage{tabu}
  \usepackage{threeparttable}
  \usepackage{threeparttablex}
  \usepackage[normalem]{ulem}
  \usepackage{makecell}

output: rticles::jss_article
bibliography: biblio.bib
biblio-style: jss
link-citations: true
---
```{r, include=FALSE}
knitr::opts_chunk$set(
  fig.path = "img/img-"
)
library(knitr)
library(kableExtra)
library(RJDemetra)
options(enable_print_style = FALSE)
# A travailler
# caption_below <- function(table){
#   lines <- strsplit(table,"\\n")[[1]]
#   caption_line <- grep("\\caption{",lines,fixed = TRUE)
#   if(length(caption_line) >0){
#     caption_line_text <- lines[caption_line]
#     caption_line_text <- sub("\\\\\\\\$","", caption_line_text)
#     lines <- gsub("\\end{longtable}",sprintf("%s\\end{longtable}", caption_line_text),lines,fixed = TRUE)
#   }
#   lines <- paste0(lines,collapse = "\\n")
#   lines
# }
```

# Introduction

The package \pkg{RJDemetra} provides a R interface to the seasonal adjustment software JDemetra+. Note that, JDemetra+ being implemented in Java, \pkg{RJDemetra} relies on the \pkg{rJava} \citep{rJava} package and Java SE 8 or later version is required. The two leading seasonal adjustment methods TRAMO/SEATS+ and X-12ARIMA/X-13ARIMA-SEATS can be used with all the specifications defined in JDemetra+.

This article is structured as following. In the first section the .. is presented. 

## Seasonal adjustment in brief 

The **first step** of seasonal adjustment, both in X-12ARIMA/X-13ARIMA-SEATS and TRAMO-SEATS+, consists of pre-adjusting the time series by removing from it the deterministic effects and estimating missing observations. Among deterministic effects, we distinguish outliers, calendar and regression effects. In this step, also forecasts and backcasts of the pre-adjusted series are estimated which allows applying linear filters at both ends of the series in the second step of the seasonal adjustment. The pre-adjustment, linearization, of the input series is achieved with a **RegARIMA** model (model with ARIMA errors) as specified below. 

$$z_t=y_t\beta+x_t$$
where

* $z_t$ - is the original series;
* $\beta = (\beta_1,...,\beta_n)$ - a vector of regression coefficients;
* $y_t = (y_{1t},...,y_{nt})$ - $n$ regression variables (outliers, calendar effects, user-defined variables);
* $x_t$ - a disturbance that follows the general ARIMA process:
* $\phi(B)\delta(B)x_t=\theta(B)a_t$; $\phi(B), \delta(B)$ and $\theta(B)$ are the finite polynomials in $B$; $a_t$ is a white-noise variable with zero mean and a constant variance.

 The polynomial $\phi(B)$ is a stationary autoregressive (AR) polynomial in $B$, which is a product of the stationary regular AR polynomial in $B$ and the stationary seasonal polynomial in $B^s$:

$$\phi(B)=\phi_p(B)\Phi_{bp}(B^s)=(1+\phi_1B+...+\phi_pB^p)(1+\Phi_1B^s+...+\Phi_{bp}B^{bps}$$

 where:

* $p$ - number of regular AR terms (in the package and in JDemetra+ $p \le 3$);
* $bp$ - number of seasonal AR terms (in the package and in JDemetra+ $bp \le 1$);
* $s$ - number of observations per year (frequency of the time series).
 
 The polynomial $\theta(B)$ is an invertible moving average (MA) polynomial in $B$, which is a product of the invertible regular MA polynomial in $B$ and the invertible seasonal MA polynomial in $B^s$:

 $$\theta(B)=\theta_q(B)\Theta_{bq}(B^s)=(1+\theta_1B+...+\theta_qB^q)(1+\Theta_1B^s+...+\Theta_{bq}B^{bqs})$$

 where:

* $q$ - number of regular MA terms (in the package and in JDemetra+ $q \le 3$);
* $bq$ - number of seasonal MA terms (in the package and in JDemetra+ $bq \le 1$);


The polynomial $\delta(B)$ is the non-stationary AR polynomial in $B$ (unit roots):

$$\delta(B)=(1-B)^d(1-B^s)^{d_s}$$

 where:

* $d$ - regular differencing order (in the package and in JDemetra+ $d \le 1$);
* $d_s$ - seasonal differencing order (in the package and in JDemetra+ $d_s \le 1$);


In the **second part** of seasonal adjustment, called the **decomposition**, the pre-adjusted series is decomposed into the following components: trend-cycle (\code{t}), seasonal component (\code{s}) and irregular component (\code{i}). The decomposition can be: 

* additive (\code{y = t + s + i})
* multiplicative (\code{y = t * s * i}) 
* log-additive (\code{log(y) = log(t)+log(s)+log(i)}) or
* pseudo-additive (\code{y = t*(s+i-1)}) 

The last two decompositions are available only under X13.

The method of decomposing the pre-adjusted series differs between TRAMO-SEATS+ and X-12ARIMA/X-13ARIMA. In TRAMO-SEATS+, SEATS ("Signal Extraction in ARIMA Time Series") decomposes the observed series with a ARIMA-model based method \citep{gomez1998automatic,caporello2004program}. Whereas in X-12ARIMA/X-13ARIMA, the X11 algorithm decomposes the time series by means of linear filters \citep{findleyx12,ladiray1999x11en}.

As a result of seasonal adjustment, the final seasonally adjusted series (\code{sa}) shall be free of seasonal and calendar-related movements.

More details on the methodlogy used in JDemetra+ can be found in the JDemetra+ manuals and user guides \citep{grudkowska2015jdemetraug, grudkowska2015jdemetrarm}.

# RJDemetra basics

The \pkg{RJDemetra} package alows to:
 
* create and modify model specifications
* create and modify models
* import/export JDemetra+ workspaces

## Dataset

In this package the sts_inpr_m database of Eurostat is included, which contains monthly industrial production indices in manufacturing in the European Union. It contains 37 time series from january 1990 to december 2017 which are considered to be affected by seasonal and working day effects. The data is a \code{ts} object and can be accessed using the \code{ipi_c_eu} object. The following snippet of code plots the industrial production index of the euro aera (EA19):

```{r basic_raw_data_plot}
library(RJDemetra)
plot(ipi_c_eu[, "EA19"])
```

# Estimate a pre-defined RegARIMA and SA model

As in JDemetra+, the \pkg{RJDemetra} package allows to perform seasonal adjustment using pre-defined model specifications. The specifications are separately defined for TRAMO-SEATS and X-13ARIMA-SEATS estimation methods. It is also possible to perform only the  first step of seasonal adjustment; the RegARIMA estimation. The pre-defined model specifications are described in tables \ref{tab:pre_def_ts} and \ref{tab:pre_def_x13}. They are identical for pre-adjustment (column 1) and for seasonal adjustment (column 2).
The pre-defined specifications correspond to most commonly used specifications and users are recommended to start their analysis with one of them. In section 5 it is presented how to modify model specifications, including the possibility to incorprate user-defined regressors.   

```{r pre_def_ts, echo=FALSE, results='asis'}
pre_def_spec_ts <- structure(list(TRAMO = c("TR0", "TR1", "TR2", "TR3", "TR4", "TR5", 
"TRfull (default)"), `TRAMO-SEATS` = c("RSA0", "RSA1", "RSA2", "RSA3", 
"RSA4", "RSA5", "RSAfull (default)"), `Trans-formation` = c("no", "test", 
"test", "test", "test", "test", "test"), `Pre-adjust-ment for leap-year` = c("no", 
"no", "no", "no", "no", "no", "yes"), `Working days` = c("no", 
"no", "test", "no", "test", "no", "no"), `Trading days` = c("no", 
"no", "no", "no", "no", "yes", "test"), `Easter effect` = c("no", 
"no", "test", "no", "test", "test (Standard)", "test (Include Easter)"
), Outliers = c("no", "test", "test", "test", "test", "test", 
"test"), `ARIMA model` = c("(0,1,1)(0,1,1)", "(0,1,1)(0,1,1)", 
"(0,1,1)(0,1,1)", "AMI", "AMI", "AMI", "AMI")), class = "data.frame", row.names = c(NA, 
-7L))
pre_def_spec_x13 <- structure(list(RegARIMA = c("RG0", "RG1", "RG2c", "RG3", "RG4c", 
"RG5c (default)"), `X-13ARIMA-SEATS` = c("X11", "RSA1", "RSA2c", "RSA3", 
"RSA4c", "RSA5 (default)"), `Trans-formation` = c("no", "test", "test", 
"test", "test", "test"), `Pre-adjust-ment for leap-year` = c("no", 
"no", "test", "no", "test", "test"), `Working days` = c("no", 
"no", "test", "no", "test", "no"), `Trading days` = c("no", "no", 
"no", "no", "no", "test"), `Easter effect` = c("no", "no", "test", 
"no", "test", "test"), Outliers = c("no", "test", "test", "test", 
"test", "test"), `ARIMA model` = c("(0,1,1)(0,1,1)", "(0,1,1)(0,1,1)", 
"(0,1,1)(0,1,1)", "AMI", "AMI", "AMI")), class = "data.frame", row.names = c(NA, 
-6L))

kable(pre_def_spec_ts, "latex", booktabs = T, caption = "Pre-defined specification for TRAMO and TRAMO-SEATS",align = "c") %>%
  column_spec(c(2,3,5), width = "1.cm") %>%
  column_spec(c(5,6,8), width = "0.9cm") %>% 
  column_spec(c(4,7), width = "1.5cm") %>% 
  kable_styling(font_size = 7) %>% 
  add_header_above(c("Specification"=2, ""))
```

```{r pre_def_x13, echo=FALSE, results='asis'}
kable(pre_def_spec_x13, "latex", booktabs = T, caption = "Pre-defined specification for RegARIMA and X-13ARIMA-SEATS", align = "c") %>%
  column_spec(c(3,5), width = "1.cm") %>%
  column_spec(c(5,6,7,8), width = "0.9cm")%>% 
  column_spec(c(2), width = "1.7cm") %>% 
  column_spec(c(4), width = "1.4cm") %>% 
  kable_styling(font_size = 7) %>% 
  add_header_above(c("Specification"=2, ""))
```

The below code presents how to perform an estimation, with pre-defined specifications, of:

* RegARIMA
  + X-13ARIMA method: \code{regarima_def_x13(series, spec = c("RG5c", "RG0", "RG1", "RG2c", "RG3","RG4c"))} 
  + TRAMO-SEATS method: \code{regarima_def_tramoseats(series, spec = c("TRfull", "TR0","TR1", "TR2","TR3", "TR4","TR5"))} 
* Seasonal adjustment
  + X-13ARIMA method: \code{x13_def(series, spec = c("RSA5c", "RSA0", "RSA1", "RSA2c", "RSA3","RSA4c"), userdefined = NULL)} 
  + TRAMO-SEATS method: \code{tramoseats_def(series, spec = c("RSAfull", "RSA0", "RSA1", "RSA2", "RSA", "RSA4", "RSA5"), userdefined = NULL)}


```{r}
library(RJDemetra)
myseries <- ipi_c_eu[, "EA19"]

regx13 <- regarima_def_x13(myseries, spec = "RG5c")
regts <- regarima_def_tramoseats(myseries, spec = "TRfull")
sax13 <- x13_def(myseries, spec = "RSA5c", userdefined = NULL)
sats <- tramoseats_def(myseries, spec = "RSAfull", userdefined = NULL)
```


# SA object structure

In the previous section it was presented how to run a RegARIMA and complete seasonal adjustment estimation with pre-defined model specifications. In this section the outcome will be described in detail. 

As a result of seasonal adjustment estimation (e.g. function \code {x13_def} or \code {tramoseats_def}) a S3 class object (\code{sa_object}) is created. It has a class \code{c("SA","X13")} or \code{c("SA","TRAMO_SEATS")} depending on the used estimation method. The \code{sa_object} consits of lists of S3 class sub-objects. For each of the class \code{print, plot} methods are defined. The complete structure of the \code{sa_object} is presented in table \ref{tab:obj_tab}. The first column gives the name of \code{sa_object} sub-components, the second the level of the sub-components, the third their type, and the fourth and fifth the name of the new created S3 classe (if any). Where the forth column corresponds to the case when the estimation is done with X-12ARIMA/X-13ARIMA and fifth when estimated with TRAMO-SEATS+. In general, the \code{sa_object} contains the following five objects: **regarima**, **decomposition**, **final**, **diagnostics** and **user_defined**. Independently which of the two methods is used the regarima, final and diagnostics objects contain the same components, though with different classes (see column 4 and 5). Whereas, the object decomposition differs for the two methods. The object user_defined is empty unless additional output was requested by the user (see next sub-sections). Finally, when estimating RegARIMA only the regarima object is created.

```{r echo=FALSE, results='asis'}
object=c("sa_object","regarima","specification","estimate","transform","regression","userdef","specification","outliers","variables","series","description","trading.days","easter","outliers","arima","specification","coefficients","forecast","span","arma","arima.coefficients","regression.coefficients","loglik","model","spec_rslt","effects","residuals","residuals.stat","st.error","tests","forecast","decomposition","specification","mode","mstats","si_ratio","s_filter","t_filter","decomposition","specification","mode","model","model","sa","trend","seasonal","transitory","irregular","linearized","components","final","series","forecasts","diagnostics","variance_decomposition","combined_test","tests_for_stable_seasonality","combined_seasonality_test","residuals_test","user_defined")
type=c("list","list","list","data.frame","data.frame","list","list","data.frame","data.frame or NA(empty)","list","mts, ts, matrix or NA(empty)","data.frame or NA(empty)","data.frame","data.frame","data.frame","list","data.frame","data.frame or NA(empty)","data.frame","data.frame","vector - numeric","matrix","matrix","matrix","list","data.frame","mts, ts, matrix","ts","list","numeric","data.frame","mts, ts, matrix","list","data.frame","character","matrix","mts, ts, matrix","vector - character","character","list","data.frame","character","list","matrix or empty list","matrix or empty list","matrix or empty list","matrix or empty list","matrix or empty list","matrix or empty list","mts, ts, matrix","mts, ts, matrix","list","mts, ts, matrix","mts, ts, matrix","list","data.frame","list","data.frame","character","data.frame","list")
class1=c("SA, X13","regarima, X13","","","","","","","","","","","","","","","","","","","","","","","","","","","","","regarima_rtests, data.frame","","decomposition_X11","X11_spec, data.frame","","","","","","","seats_spec, data.frame","","","","","","","","","","","final","","","diagnostics","","combined_test","","","","user_defined")
class2=c("SA, TRAMO_SEATS","regarima, TRAMO_SEATS","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","decomposition_SEATS","","","","","","","","","","","","","","","","","","","","","")
level=c(0,1,2,3,3,3,4,5,5,5,6,6,4,4,3,3,4,4,3,3,2,2,2,2,2,3,3,2,2,3,3,2,1,2,2,2,2,2,2,1,2,2,2,3,3,3,3,3,3,2,2,1,2,2,1,2,2,3,3,2,1)

obj_tab <-data.frame(cbind(object,level,type,class1,class2),stringsAsFactors = FALSE)

obj_tab[obj_tab[,"level"]==1,1] <- paste0("\\hspace{1em}",obj_tab[obj_tab[,"level"]==1,1])
obj_tab[obj_tab[,"level"]==2,1] <- paste0("\\hspace{2em}",obj_tab[obj_tab[,"level"]==2,1])
obj_tab[obj_tab[,"level"]==3,1] <- paste0("\\hspace{3em}",obj_tab[obj_tab[,"level"]==3,1])
obj_tab[obj_tab[,"level"]==4,1] <- paste0("\\hspace{4em}",obj_tab[obj_tab[,"level"]==4,1])
obj_tab[obj_tab[,"level"]==5,1] <- paste0("\\hspace{5em}",obj_tab[obj_tab[,"level"]==5,1])
obj_tab[obj_tab[,"level"]==6,1] <- paste0("\\hspace{6em}",obj_tab[obj_tab[,"level"]==6,1])

obj_tab <- apply(obj_tab, 2, function(x)gsub("_","\\_",x,fixed = TRUE))
colnames(obj_tab)=c("Object","Level","Type","Class","Class")

kable(obj_tab, "latex", longtable = T,escape = FALSE, booktabs = T, caption = "\\label{tab:obj_tab}SA object structure")%>%
  
  add_header_above(c(" "," "," ","x13/x13_def"," tramoseats/tramoseats_def"), italic = T)%>%
  
  add_header_above(c(" "," "," ","When adjusted with:" = 2))%>%
  
  row_spec(c(2,33,40,52,55,61), bold = T)%>% 
  
  kable_styling(font_size = 7)
  
```

## Regarima

Here we can also present the output: print and graphs.
```{r}
library(RJDemetra)
myseries <- ipi_c_eu[, "EA19"]
sax13 <- x13_def(myseries, spec = "RSA5c", userdefined = NULL)
sats <- tramoseats_def(myseries, spec = "RSAfull", userdefined = NULL)
## PRINT THE RESULTS:
sax13$regarima
## PLOT THE RESULTS:
#plot(sax13$regarima)
```

## Decomposition

## Final

## Diagnostics

## user defined

# Model specification: creation and modification 

## X13

## TRAMOSEATS

## Regarima 

## Wrong specifications corrections
Parler des corrections automatiques ?
  
# Manipulate JDemetra+ workspaces

\pkg{RJDemetra} allows to interact with JDemetra+ workspace that can be openned by the software. A workspace includes :

- The XML file that enables the user to import the workspace to JDemetra+ and to display it content;  
- A folder containing several sub-folfders that correspond to the different types of items created by the user.

Each workspace can contain several multi-processings and each multi-processing stores the results of the seasonal adjustment procedure performed with the TRAMO/SEATS or X-13ARIMA-SEATS methods.

Export models to workspace allows to store easily the seasonal adjustment models, to change the specifications with the JDemetra+ graphical interface and to give models to non R users (Ã  reformuler).

## Export a workspace {#export-wk}

Four functions have to be used to export models:

- \code{new_workspace()} to create a workspace;  
- \code{new_multiprocessing()} to create a multi-processing in a workspace;  
- \code{add_sa_item()} to add a seasonal adjustment model to a multi-processing;  
- \code{save_workspace()} to export the workspace.  

The following command export the seasonal adjustment models compute by TRAMO/SEATS+ and X-13ARIMA-SEATS:

```{r}
myseries <- ipi_c_eu[, "EA19"]
sa_x13 <- x13_def(myseries)
sa_ts <- tramoseats_def(myseries)
```

To create a workspace and a multi-processing names "MP-1":
```{r}
wk <- new_workspace()
new_multiprocessing(wk, name = "MP-1")
```

The two models will be added in the multiprocessing "MP1": the name of the seasonal adjustment model computed with X-13ARIMA-SEATS will be "SA with X13" and the one with TRAMO/SEATS+ will be SA with TramoSeats".

```{r}
add_sa_item(wk, multiprocessing = "MP-1",
            sa_obj = sa_x13, name =  "SA with X13")
add_sa_item(wk, multiprocessing =  "MP-1",
            sa_obj = sa_ts, name = "SA with TramoSeats")
```

The workspace exported is named "workspace.xml":
```{r}
save_workspace(wk, file =  "workspace.xml")
```


## Import a workspace

Height functions can be used to import a workspace: 

- \code{load_workspace()} to load a workspace;  
- \code{compute()} to compute the multi-processings: by default a workspace only contains definitions, computation is needed to get the seasonal adjustment model;  
- \code{get_model()} to get the seasonal adjusted models;  
- \code{get_ts()} to get the input raw time series,  \code{get_object()} and \code{get_all_objects} to navigate inside the workspace (extract a multi-processing or a seasonal adjustment model), \code{get_name()} to get the names of the multiprocessings or the seasonal adjustment models and \code{count()} to count the number of multiprocessing or seasonal adjustment models.

For instance, to import the workspace created in section \ref{export-wk} and to get the first multiprocessing and the first seasonal adjustment model:

```{r}
wk <- load_workspace(file =  "workspace.xml")
mp1 <- get_object(wk, 1) # first multiprocessing
sa_item1 <- get_object(mp1, 1) #  first seasonal adjustment model
```

To get the number of seasonal adjustment models in the multiprocessing:
```{r}
count(mp1)
```

And the name of the first seasonal adjustment model in JDemetra+:
```{r}
get_name(sa_item1) 
```

Raw time series and seasonal adjustment model can now be imported:
```{r}
raw_ts <- get_ts(sa_item1)
compute(wk)
sa_model1 <- get_model(sa_item1, workspace = wk)
```

\code{get_ts()} and \code{get_model()} can also be used directly to the workspace or a multiprocessing to import all the raw time series or all the seasonal adjustment model:

- for a multiprocessing the result is a list which each element contains the information of a seasonal adjustment model;  
- for a workspace the result is a list of length the number of multi-processing and which each element contains a list with the information of each seasonal adjustment model.

For example to get all raw time series of the workspace and all seasonal adjustmen models of the first multi-processing:

```{r, eval=FALSE}
all_raw_ts <- get_ts(wk)
sa_models_of_mp1 <- get_model(mp1, workspace = wk)
```

The imports of seasonal adjustment models from a workspace works well when it has been created throw \pkg{RJDemetra}. They may be some troubles when importing a workspace created with JDemetra+, in particular:

- \pkg{RJDemetra} doesn't support yet user-defined calendars. A seasonal adjustment model defined with a specific calendar or user-defined calendar regressors will be partially imported. The result will be correct but changing the specification (throw \code{x13_spec()} or \code{tramoseats_spec()}) will erase user-defined calendars.  
- Seasonal adjustment models with ramp effect or intervention variables will be partially imported: the result of the imported model will be correct but changing the specification (throw \code{x13_spec()} or \code{tramoseats_spec()}) will erase them.  
- Seasonal adjustment models with no pre-processing (X11 specification) are not supported: \code{NULL} object will be returned.


# Advanced usage and examples

# Conclusion

# Acknowledgments {-}


# References


