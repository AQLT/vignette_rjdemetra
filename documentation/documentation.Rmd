---
author:
  - name: Anna Michalek
    affiliation: European Central Bank
    email: \email{anna.michalek@ecb.int}
  - name: Alain Quartier-la-Tente
    affiliation: "Insee"
    email: \email{alain.quartier@gmail.com}
title:
  formatted: "\\pkg{RJDemetra}: An \\proglang{R} Interface To \\proglang{JDemetra+} Seasonal Adjustment Software"
  # If you use tex in the formatted title, also supply version without
  plain:     "RJDemetra: An R Interface To JDemetra+ Seasonal Adjustment Software"
abstract: >
  \pkg{RJDemetra} provides an interface between \proglang{R} and \proglang{JDemetra+}, the only seasonal and trading days adjustment software officially recommended by Eurostat to the members of the European Statistical System and the European System of Central Banks. \pkg{RJDemetra} offers access to main options and outputs of \proglang{JDemetra+}, including the two leading seasonal adjustment methods TRAMO-SEATS and X-13ARIMA. Thus, it is possible to use user-defined or pre-specified specification and to estimate a RegARIMA model including automatic outlier and ARIMA detection, moving holiday effects and user-defined regressors. With \pkg{RJDemetra} it is also possible to read and write \proglang{JDemetra+} workspaces that are used in production. Thus, thanks to all the resources available in \proglang{R}, it offers large possibilities to develop tools to improve the production of seasonal adjusted series.
  
keywords:
  # at least one keyword must be supplied
  formatted: ["\\proglang{R}", seasonal adjustment, calendar effects, ARIMA, outliers, time series]
  plain:     [R, seasonal adjustment, calendar effects, ARIMA, outliers, time series]
preamble: >
  \usepackage{amsmath}
  \usepackage{booktabs}
  \usepackage{longtable}
  \usepackage{array}
  \usepackage{multirow}
  \usepackage{wrapfig}
  \usepackage{float}
  \usepackage{pdflscape}
  \usepackage{tabu}
  \usepackage{threeparttable}
  \usepackage{threeparttablex}
  \usepackage[normalem]{ulem}
  \usepackage{makecell}

output: rticles::jss_article
bibliography: biblio.bib
biblio-style: jss
link-citations: true
---
```{r, include=FALSE}
knitr::opts_chunk$set(
  fig.path = "img/img-"
)
library(knitr)
library(kableExtra)
library(RJDemetra)
options(enable_print_style = FALSE)
# A travailler
# caption_below <- function(table){
#   lines <- strsplit(table,"\\n")[[1]]
#   caption_line <- grep("\\caption{",lines,fixed = TRUE)
#   if(length(caption_line) >0){
#     caption_line_text <- lines[caption_line]
#     caption_line_text <- sub("\\\\\\\\$","", caption_line_text)
#     lines <- gsub("\\end{longtable}",sprintf("%s\\end{longtable}", caption_line_text),lines,fixed = TRUE)
#   }
#   lines <- paste0(lines,collapse = "\\n")
#   lines
# }
```

# Introduction

Since the 20th century, more and more infra-annual statistics are produced, especially by national institutes, to analyse the short-term evolution of economies. It is for example the case of the gross domestic product (GDP), unemployment rate, household consumption of goods and industrial production indices. However, most of those time series are affected by seasonal and trading days effects. A seasonal effect is an effect that occurs in the same calendar month with similar magnitude and direction from year to year. For instance, automobile production is usually lower during summer, due to holidays, and chocolate sales are usually higher in December, due to Christmas. Trading days effect appears when a time series is affected by calendar month’s weekday composition. For example retail sales are usually higher on Saturday, thus they are likely to be higher in months with a surplus of weekend days.

Seasonal and trading days effects can hamper the analysis of infra-annual movements of a time series or the spatial comparison. This is the reason why time series are often seasonally and trading days adjusted, where seasonal adjustment is the process of removing the effects of seasonal and trading day fluctuations.

# Theory behind seasonal adjustment

The most popular seasonal adjustment methods are TRAMO-SEATS[^1] [@gomez1996programs; @caporello2004program], a parametric method based on ARIMA models, and X-13ARIMA[^2] [@findleyx12; @ladiray1999x11en], a non-parametric method based on moving averages. Both methods are recommended by Eurostat and the European Central Bank (ECB) for adjusting economic indicators. These two methods proceed in two steps, summarized in figure \ref{fig:2_step_proc}.

[^1]: The program \proglang{TRAMO-SEATS} was developed by Gianluca Caporello and Agustin Maravall --- with programming support from Domingo Perez and Roberto Lopez --- at the Bank of Spain. It is based on the program TRAMO-SEATS, previously developed by Victor Gomez and Agustin Maravall.

[^2]: The program \proglang{X-13ARIMA} is a produced, distributed, and maintained by the US-Census Bureau.

\begin{figure}[htb]
\centering
\includegraphics[scale=0.8]{img/sa_2_steps.PNG} 
\caption{X-13ARIMA and TRAMO-SEATS 2-step process: pre-adjustment and decomposition.}
\label{fig:2_step_proc}
\end{figure}

The **first step**, called **pre-adjustment** or **linearisation**, consists of pre-adjusting the time series by removing the deterministic effects and estimating missing observations. Next, in the **second part** of seasonal adjustment, called the **decomposition**, the pre-adjusted series is decomposed in order to determine the seasonal component. As a result of this process, the final seasonally adjusted series shall be free of seasonal and calendar-related movements.
 
The pre-adjustment step is very similar in X-13ARIMA and in TRAMO-SEATS (section \ref{pre-adjustment}), whereas the decomposition differs between the two methods. In X-13ARIMA, the X-11 algorithm decomposes the time series by means of linear filters (section \ref{sa-x11}). In TRAMO-SEATS, SEATS (Signal Extraction in ARIMA Time Series) decomposes the observed series with a ARIMA-model based method (section \ref{sa-seats}).


## Pre-adjustment with TRAMO and RegARIMA models {#pre-adjustment}

As aforementioned, the **first step** of seasonal adjustment consists of pre-adjusting the time series by removing from it the deterministic effects like outliers, calendar and regression effects. This step estimates also the missing observations, as well as produces forecasts and backasts of the pre-adjusted series which allows applying linear filters at both ends of the series in the decomposition part of the seasonal adjustment. All this is achieved with a **RegARIMA** model (model with ARIMA errors) as specified below. 

$$z_t=y_t\beta+x_t$$
where

* $z_t$ - is the original series;
* $\beta = (\beta_1,\dots,\beta_n)$ - a vector of regression coefficients;
* $y_t = (y_{1t},\dots,y_{nt})$ - $n$ regression variables (outliers, calendar effects, user-defined variables);
* $x_t$ - a disturbance that follows the general ARIMA process:
* $\phi(B)\delta(B)x_t=\theta(B)a_t$; $\phi(B), \delta(B)$ and $\theta(B)$ are the finite polynomials in $B$; $a_t$ is a white-noise variable with zero mean and a constant variance.

 The polynomial $\phi(B)$ is a stationary autoregressive (AR) polynomial in $B$, which is a product of the stationary regular AR polynomial in $B$ and the stationary seasonal polynomial in $B^s$:

$$\phi(B)=\phi_p(B)\Phi_{bp}(B^s)=(1+\phi_1B+\dots+\phi_pB^p)(1+\Phi_1B^s+\dots+\Phi_{bp}B^{bps})$$

 where:

* $p$ - number of regular AR terms (in the package and in \proglang{JDemetra+} $p \le 3$);
* $bp$ - number of seasonal AR terms (in the package and in \proglang{JDemetra+} $bp \le 1$);
* $s$ - number of observations per year (frequency of the time series).
 
 The polynomial $\theta(B)$ is an invertible moving average (MA) polynomial in $B$, which is a product of the invertible regular MA polynomial in $B$ and the invertible seasonal MA polynomial in $B^s$:

 $$\theta(B)=\theta_q(B)\Theta_{bq}(B^s)=(1+\theta_1B+\dots+\theta_qB^q)(1+\Theta_1B^s+\dots+\Theta_{bq}B^{bqs})$$

 where:

* $q$ - number of regular MA terms (in the package and in \proglang{JDemetra+} $q \le 3$);
* $bq$ - number of seasonal MA terms (in the package and in \proglang{JDemetra+} $bq \le 1$);


The polynomial $\delta(B)$ is the non-stationary AR polynomial in $B$ (unit roots):

$$\delta(B)=(1-B)^d(1-B^s)^{d_s}$$

 where:

* $d$ - regular differencing order (in the package and in \proglang{JDemetra+} $d \le 1$);
* $d_s$ - seasonal differencing order (in the package and in \proglang{JDemetra+} $d_s \le 1$);

Furthermore, in this step an automatic modelling is implemented (in both methods) to: determine the decomposition of the series, detect outliers and calendar effects and to adjust residuals to an ARIMA models. A detailed description can be found in \cite{gomez1998automatic}.

## Decomposition with X-11 {#sa-x11}

In this step, the pre-adjusted series ($y$) is decomposed into the following components: trend-cycle ($t$), seasonal component ($s$) and irregular component ($i$), where the decomposition can be: 

* additive ($y = t + s + i$);  
* multiplicative ($y = t \times s \times i$);  
* log-additive ($\log(y) = \log(t) + \log(s) + \log(i)$);  
* pseudo-additive ($y = t \times (s + i - 1)$). 

In X-11, which is an iterative non-parametric method, the decomposition is achieved by means of linear filters [@findleyx12; @ladiray1999x11en].
The basic procedure consists of a simple 3-step algorithm:
 
1) Estimate the trend by means of moving averages; 
2) Remove the trend and leave the seasonal and irregular components; 
3) Estimate the seasonal component using moving averages.

At each step, the program selects a moving average among a large set of predefined smoothers, according to the characteristics of the series.
X-11 also incorporates an automatic detection and correction of (additive) outliers to make the use of linear filters more robust.


## Decomposition with SEATS {#sa-seats}

SEATS is a program for decomposing time series into their unobserved components following an ARIMA model that extracts from a time series its different signals [@gomez1996programs; @caporello2004program]. The decomposition can be:

* additive or ;
* multiplicative (equivalent to an additive model after taking the logarithm).

SEATS decomposes the linearized series into the following components:

- **trend-cycle component:** captures the low-frequency variation of the series and displays a spectral peak at frequency 0;  
- **seasonal component:** captures the spectral peaks at seasonal frequencies;  
- **irregular component:** captures erratic, white-noise behaviour, and hence has a flat spectrum;  
- **transitory component:** a zero-mean stationary component that picks up transitory fluctuations that should not contaminate the trend-cycle or seasonal component and are not white-noise.

The components are determined and fully derived from the structure of the ARIMA model for the observed series.

The decomposition assumes orthogonal components, and each one will have in turn an ARIMA expression. In order to identify the components, it is required that (except for the irregular one) they are clean of noise. This is called the "canonical" property, and implies that no additive white noise can be extracted from a component that is not the irregular one. The variance of the latter is, in this way, maximized, and, on the contrary, the trend-cycle and seasonal component are as stable as possible (compatible with the stochastic nature of model). 

\section[JDemetra+ and RJDemetra]{\proglang{JDemetra+} and \pkg{RJDemetra}}

\proglang{JDemetra+} is a tool for seasonal adjustment (SA) developed by the National Bank of Belgium (NBB) in cooperation with the Deutsche Bundesbank and Eurostat in accordance with the Guidelines of the European Statistical System (ESS) [@eurostat2015guidelines]. It implements the concepts and algorithms used in the two leading seasonal adjustment methods: TRAMO-SEATS and X-13ARIMA. Those methods have been re-engineered using an object-oriented approach that facilitates estimations handling, extensions and modifications.

\proglang{JDemetra+} has been [officially recommended](https://ec.europa.eu/eurostat/cros/system/files/Jdemetra_%20release.pdf), since 2 February 2015, to the members of the ESS and the European System of Central Banks as software for seasonal and calendar adjustment of official statistics.

Besides seasonal adjustment, \proglang{JDemetra+} bundles other time series models that are useful in the production and analysis of economic statistics, including for instance outlier detection, nowcasting, temporal disaggregation or benchmarking. More details on the methodology used in \proglang{JDemetra+} can be found in the \proglang{JDemetra+} manuals and user guides [@grudkowska2015jdemetrarm; @grudkowska2015jdemetraug].

The package \pkg{RJDemetra} [@RJDemetra] provides an R interface to the seasonal adjustment software \proglang{JDemetra+}. \pkg{RJDemetra} uses Java libraries of \proglang{JDemetra+}, therfore relies on the \pkg{rJava} [@rJava] package. Consequently Java SE 8 or later versions are required. The package allows to:

* perform seasonal adjustment with TRAMO-SEATS and X-13ARIMA with pre-defined (section \ref{pre-def-est}) and user-defined specifications (section \ref{user-def-spec});  
* access all outputs available in \proglang{JDemetra+} (section \ref{sa-obj-struc});  
* import and export \proglang{JDemetra+} workspaces (section \ref{manipulate-workspace}).

It can be installed from CRAN:

```{r, eval= FALSE}
install.packages("RJDemetra")
```

The development version can be installed from GitHub with \pkg{devtools} [@devtools]:
```{r, eval= FALSE}
devtools::install_github("jdemetra/rjdemetra")
```

For the moment the seasonal and trading day adjustment can only be done for monthly, bimonthly (for TRAMO-SEATS only), quarterly and half-yearly data. By the end of 2020 \proglang{JDemetra+}, and therefore \pkg{RJDemetra}, will be extended to be compatible with every biannual frequency (daily, weekly, etc.).

## Dataset

The package \pkg{RJDemetra} includes the `sts_inpr_m` database of the Eurostat, which contains monthly industrial production indices in manufacturing for the European Union. It contains 37 time series from January 1990 to December 2017 which are considered to be affected by seasonal and trading days effects. The data are \code{ts} objects and can be accessed using the \code{ipi_c_eu} object. The following snippet of code plots the industrial production index of the euro area (EA19):

```{r basic_raw_data_plot}
library(RJDemetra)
plot(ipi_c_eu[, "EA19"])
```

## Print styling

By default, a colour styling is used for the \code{print} methods of the objects created by \pkg{RJDemetra}. It can causes troubles with some outputs --- for example with \pkg{rmarkdown} [@rmarkdown] --- and can be disabled in each \code{print} function with the argument \code{enable_print_style = FALSE} or setting the global option \code{enable_print_style} to \code{FALSE}:

```{r}
options(enable_print_style = FALSE)
```


# Estimate a pre-defined RegARIMA and seasonal adjustment model {#pre-def-est}

As in \proglang{JDemetra+}, \pkg{RJDemetra} allows to perform seasonal adjustment using pre-defined model specifications that are the most commonly used specifications and are recommended to users for the start of their analysis. They are separately defined for TRAMO-SEATS and X-13ARIMA methods. It is also possible to perform only the  first step of seasonal adjustment; i.e. the RegARIMA estimation. The pre-defined model specifications are described in detail in tables \ref{tab:pre_def_ts} and \ref{tab:pre_def_x13}. They are identical for pre-adjustment (column 1) and for seasonal adjustment (column 2). The settings described in tables \ref{tab:pre_def_ts} and \ref{tab:pre_def_x13} refer to:

* Transformation: test to choose between an additive decomposition (no transformation) and a multiplicative decomposition (logarithmic transformation).  
* Pre-adjustment for leap-year (not available for TRAMO): in the case of a multiplicative decomposition a correction of the February values is applied to the original series (before transformation). The original values in February are multiplied by $\frac{28.25}{29}$ for leap years, by $\frac{28.25}{28}$  for non-leap years and values for other months are not modified. In the case of multiplicative models, this is equivalent to adding a leap year regressor [@bell1992lengthmonthadj].  
* Working days/trading days: test for the presence of working day/trading day effects. In TRAMO an automatic choice between working days and trading days regressors is done with "RSAFull".  
* Easter: pre-test for the presence of  the Easter effect. For TRAMO-SEATS the default length of the Easter effect is 6 days and for X-13ARIMA an automatic detection of the duration is done (1, 8 or 15 days).  
* Outliers: an automatic identification of three types of outliers: AO (additive outlier), LS (level shift) and TC (transitory change), using a default critical value. The automatic identification of SO (seasonal outlier) is not enabled by default.  
* ARIMA model: the choice between fixing the ARIMA model structure to (0,1,1)(0,1,1) (Airline model) or searching for ARIMA model orders using an automatic model identification procedure. The Airline model is used as a default model in several TRAMO-SEATS and X-13ARIMA specifications as it has been shown in several studies that it is appropriate in many cases for real seasonal monthly or a quarterly time series. Moreover, the Airline model approximates well many other models and provides an excellent "benchmark" model [@maravall2009identification].


```{r pre_def_ts, echo=FALSE, results='asis'}
pre_def_spec_ts <- structure(list(TRAMO = c("TR0", "TR1", "TR2", "TR3", "TR4", "TR5", 
"TRfull (default)"), `TRAMO-SEATS` = c("RSA0", "RSA1", "RSA2", "RSA3", 
"RSA4", "RSA5", "RSAfull (default)"), `Trans-formation` = c("no", "test", 
"test", "test", "test", "test", "test"), `Pre-adjust-ment for leap-year` = c("no", 
"no", "no", "no", "no", "no", "yes"), `Working days` = c("no", 
"no", "test", "no", "test", "no", "test"), `Trading days` = c("no", 
"no", "no", "no", "no", "yes", "test"), `Easter effect` = c("no", 
"no", "test", "no", "test", "test (Standard)", "test (Include Easter)"
), Outliers = c("no", "test", "test", "test", "test", "test", 
"test"), `ARIMA model` = c("(0,1,1)(0,1,1)", "(0,1,1)(0,1,1)", 
"(0,1,1)(0,1,1)", "AMI", "AMI", "AMI", "AMI")), class = "data.frame", row.names = c(NA, 
-7L))
pre_def_spec_x13 <- structure(list(RegARIMA = c("RG0", "RG1", "RG2c", "RG3", "RG4c", 
"RG5c (default)"), `X-13ARIMA` = c("", "RSA1", "RSA2c", "RSA3", 
"RSA4c", "RSA5 (default)"), `Trans-formation` = c("no", "test", "test", 
"test", "test", "test"), `Pre-adjust-ment for leap-year` = c("no", 
"no", "test", "no", "test", "test"), `Working days` = c("no", 
"no", "test", "no", "test", "no"), `Trading days` = c("no", "no", 
"no", "no", "no", "test"), `Easter effect` = c("no", "no", "test", 
"no", "test", "test"), Outliers = c("no", "test", "test", "test", 
"test", "test"), `ARIMA model` = c("(0,1,1)(0,1,1)", "(0,1,1)(0,1,1)", 
"(0,1,1)(0,1,1)", "AMI", "AMI", "AMI")), class = "data.frame", row.names = c(NA, 
-6L))

kable(pre_def_spec_ts, "latex", booktabs = T, caption = "Pre-defined specification for TRAMO and TRAMO-SEATS",align = "c") %>%
  column_spec(c(2,3,5), width = "1.cm") %>%
  column_spec(c(5,6,8), width = "0.9cm") %>% 
  column_spec(c(4,7), width = "1.5cm") %>% 
  kable_styling(font_size = 7) %>% 
  add_header_above(c("Specification"=2, ""))
```

```{r pre_def_x13, echo=FALSE, results='asis'}
kable(pre_def_spec_x13, "latex", booktabs = T, caption = "Pre-defined specification for RegARIMA and X-13ARIMA", align = "c") %>%
  column_spec(c(3,5), width = "1.cm") %>%
  column_spec(c(5,6,7,8), width = "0.9cm")%>% 
  column_spec(c(2), width = "1.7cm") %>% 
  column_spec(c(4), width = "1.4cm") %>% 
  kable_styling(font_size = 7) %>% 
  add_header_above(c("Specification"=2, ""))
```


To estimate a model with a pre-defined specification the following four functions can be used in \pkg{RJDemetra}:

* RegARIMA
  + X-13ARIMA method: \code{regarima_x13()} 
  + TRAMO-SEATS method: \code{regarima_tramoseats()} 
* Seasonal adjustment
  + X-13ARIMA method: \code{x13()} 
  + TRAMO-SEATS method: \code{tramoseats()}

Where the second argument refers to model specifications as described in table \ref{tab:pre_def_ts} and \ref{tab:pre_def_x13}. 

For example:

```{r}
myseries <- ipi_c_eu[, "EA19"]
regx13 <- regarima_x13(myseries, spec = "RG5c")
regts <- regarima_tramoseats(myseries, spec = "TRfull")
sax13 <- x13(myseries, spec = "RSA3", userdefined = NULL)
sats <- tramoseats(myseries, spec = "RSAfull", userdefined = NULL)
```

As aforementioned the model specifications can be modified by users, including the possibility to incorporate user-defined regressors. How to do it is described in section \ref{user-def-spec}.

# Class object structure {#sa-obj-struc}

To recap, section \ref{pre-def-est} presented how to run a RegARIMA and complete seasonal adjustment estimation with pre-defined model specifications. This section, in turn, presents the outcome of it.

As a result of seasonal adjustment estimation (e.g. function \code{x13} or \code {tramoseats}) a S3 class object (\code{sa_object}) is created. It has a class \code{c("SA", "X13")} or \code{c("SA", "TRAMO_SEATS")} depending on the used estimation method. The \code{sa_object} is a list of the following S3 class sub-objects: **regarima**, **decomposition**, **final**, **diagnostics** and **user_defined**. The complete structure of the \code{sa_object} is presented in table \ref{tab:obj_tab_x13} for seasonal adjustment made with \code{x13} and in table \ref{tab:obj_tab_tramoseats} for seasonal adjustment made with \code{tramoseats}. Independently which of the two estimation methods is used, the \code{regarima}, \code{final} and \code{diagnostics} objects contain the same components, though with different classes (see tables \ref{tab:obj_tab_x13} and \ref{tab:obj_tab_tramoseats}). Whereas, the object decomposition differs for the two methods. The object user_defined is empty unless additional output was requested by the user (see sub-section \ref{user-def}). Finally, when estimating RegARIMA only the \code{regarima} object is created. For each of the class \code{print} and \code{plot} methods are defined. All the plots methods are detailed in table \ref{tab:plots_methods}.

```{r obj_tab_x13, echo=FALSE, results='asis'}
object=c("sa_object", "regarima", "specification", "estimate", "transform", 
"regression", "userdef", "specification", "outliers", "variables", 
"series", "description", "trading.days", "easter", "outliers", 
"arima", "specification", "coefficients", "forecast", "span", 
"arma", "arima.coefficients", "regression.coefficients", "loglik", 
"model", "spec_rslt", "effects", "residuals", "residuals.stat", 
"st.error", "tests", "forecast", "decomposition", "specification", 
"mode", "mstats", "si_ratio", "s_filter", "t_filter", "final", 
"series", "forecasts", "diagnostics", "variance_decomposition", 
"combined_test", "tests_for_stable_seasonality", "combined_seasonality_test", 
"residuals_test", "user_defined")
type=c("list [SA, X13]",
       "list [regarima, X13] ","list","data.frame","data.frame","list","list","data.frame","data.frame or NA(empty)","list","mts, ts, matrix or NA(empty)","data.frame or NA(empty)","data.frame","data.frame","data.frame","list","data.frame","data.frame or NA(empty)","data.frame","data.frame","vector - numeric","matrix","matrix","matrix","list","data.frame","mts, ts, matrix","ts","list","numeric",
       "data.frame [regarima_rtests]","mts, ts, matrix",
       "list [decomposition_X11]","data.frame [X11_spec]","character","matrix","mts, ts, matrix","vector - character","character",
       "list [finals]","mts, ts, matrix","mts, ts, matrix",
       "list [diagnostics]","data.frame",
       "list [combined_test]","data.frame","character","data.frame",
       "list [user_defined]")
level=c(0, 1, 2, 3, 3, 3, 4, 5, 5, 5, 6, 6, 4, 4, 3, 3, 4, 4, 3, 3, 
2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 
2, 1, 2, 2, 3, 3, 2, 1)

obj_tab <-data.frame(cbind(object,level,type),stringsAsFactors = FALSE)

obj_tab[obj_tab[,"level"]==1,1] <- paste0("\\hspace{1em}",obj_tab[obj_tab[,"level"]==1,1])
obj_tab[obj_tab[,"level"]==2,1] <- paste0("\\hspace{2em}",obj_tab[obj_tab[,"level"]==2,1])
obj_tab[obj_tab[,"level"]==3,1] <- paste0("\\hspace{3em}",obj_tab[obj_tab[,"level"]==3,1])
obj_tab[obj_tab[,"level"]==4,1] <- paste0("\\hspace{4em}",obj_tab[obj_tab[,"level"]==4,1])
obj_tab[obj_tab[,"level"]==5,1] <- paste0("\\hspace{5em}",obj_tab[obj_tab[,"level"]==5,1])
obj_tab[obj_tab[,"level"]==6,1] <- paste0("\\hspace{6em}",obj_tab[obj_tab[,"level"]==6,1])

obj_tab <- apply(obj_tab, 2, function(x)gsub("_","\\_",x,fixed = TRUE))
colnames(obj_tab)=c("Object","Level","Type [RJDemetra S3 class]")
kable(obj_tab, "latex", longtable = T,escape = FALSE, booktabs = T,
      caption = "\\code{SA} object structure (seasonal adjustment made with \\code{x13})") %>%
  row_spec(c(2,33,40,43,49), bold = T)
  
```


```{r obj_tab_tramoseats, echo=FALSE, results='asis'}
object=c("sa_object", "regarima", "specification", "estimate", "transform", 
"regression", "userdef", "specification", "outliers", "variables", 
"series", "description", "trading.days", "easter", "outliers", 
"arima", "specification", "coefficients", "forecast", "span", 
"arma", "arima.coefficients", "regression.coefficients", "loglik", 
"model", "spec_rslt", "effects", "residuals", "residuals.stat", 
"st.error", "tests", "forecast", "decomposition", 
"specification", "mode", "model", "model", "sa", "trend", "seasonal", 
"transitory", "irregular", "linearized", "components", "final", 
"series", "forecasts", "diagnostics", "variance_decomposition", 
"combined_test", "tests_for_stable_seasonality", "combined_seasonality_test", 
"residuals_test", "user_defined")
type=c("list [SA, X13]",
       "list [regarima, X13] ","list","data.frame","data.frame","list","list","data.frame","data.frame or NA(empty)","list","mts, ts, matrix or NA(empty)","data.frame or NA(empty)","data.frame","data.frame","data.frame","list","data.frame","data.frame or NA(empty)","data.frame","data.frame","vector - numeric","matrix","matrix","matrix","list","data.frame","mts, ts, matrix","ts","list","numeric",
       "data.frame [regarima_rtests]","mts, ts, matrix",
       "list [decomposition_seats]","data.frame [seats_spec]","character","list","matrix or empty list","matrix or empty list","matrix or empty list","matrix or empty list","matrix or empty list","matrix or empty list","mts, ts, matrix","mts, ts, matrix",
       "list [finals]","mts, ts, matrix","mts, ts, matrix",
       "list [diagnostics]","data.frame",
       "list [combined_test]","data.frame","character","data.frame",
       "list [user_defined]")
level=c(0, 1, 2, 3, 3, 3, 4, 5, 5, 5, 6, 6, 4, 4, 3, 3, 4, 4, 3, 3, 
2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 2, 1, 2, 2, 2, 3, 3, 3, 3, 3, 
3, 2, 2, 1, 2, 2, 1, 2, 2, 3, 3, 2, 1)

obj_tab <-data.frame(cbind(object, level, type),stringsAsFactors = FALSE)

obj_tab[obj_tab[,"level"]==1,1] <- paste0("\\hspace{1em}",obj_tab[obj_tab[,"level"]==1,1])
obj_tab[obj_tab[,"level"]==2,1] <- paste0("\\hspace{2em}",obj_tab[obj_tab[,"level"]==2,1])
obj_tab[obj_tab[,"level"]==3,1] <- paste0("\\hspace{3em}",obj_tab[obj_tab[,"level"]==3,1])
obj_tab[obj_tab[,"level"]==4,1] <- paste0("\\hspace{4em}",obj_tab[obj_tab[,"level"]==4,1])
obj_tab[obj_tab[,"level"]==5,1] <- paste0("\\hspace{5em}",obj_tab[obj_tab[,"level"]==5,1])
obj_tab[obj_tab[,"level"]==6,1] <- paste0("\\hspace{6em}",obj_tab[obj_tab[,"level"]==6,1])

obj_tab <- apply(obj_tab, 2, function(x)gsub("_","\\_",x,fixed = TRUE))
colnames(obj_tab)=c("Object","Level","Type [RJDemetra S3 class]")
kable(obj_tab, "latex", longtable = T,escape = FALSE, booktabs = T,
      caption = "\\code{SA} object structure (seasonal adjustment made with \\code{tramoseats})") %>%
  row_spec(c(2,33,45,48,50,54), bold = T)
  
```

```{r plots_methods, echo=FALSE, results='asis'}
plot_methods <- structure(list(`Object class (\\code{x} object)` = c("\\code{regarima}", 
                                                            "\\code{regarima}", "\\code{regarima}", " \\code{regarima}", 
                                                            "\\code{regarima}", "\\code{regarima}", " \\code{regarima}", 
                                                            "\\code{decomposition_X11}, \\code{decomposition_SEATS}", " \\code{final}", 
                                                            "\\code{final} or \\code{SA}"), Method = c("\\code{plot(x, which = 1)}", "\\code{plot(x, which = 2)}", 
                                                                                          "\\code{plot(x, which = 3)}", "\\code{plot(x, which = 4)}", "\\code{plot(x, which = 5)}", 
                                                                                          "\\code{plot(x, which = 6)}", "\\code{plot(x, which = 7)}", "\\code{plot(x)}", 
                                                                                          "\\code{plot(x, type_chart = sa-trend)}", "\\code{plot(x, type_chart = cal-seas-irr)}"
                                                            ), Description = c("Plot of residuals", "Histogram of standardized residuals and density", 
                                                                               "Normal quantile-quantile (Q-Q) plot of standardized residuals", 
                                                                               "Autocorrelation function (ACF) of residuals", "Partial autocorrelation function (PACF) of residuals", 
                                                                               "Raw and linearized series", "Plots 3 graphics: linearized series, calendar effects and outliers effects", 
                                                                               "S-I ratio: seasonal-irregular (S-I) component and the seasonal factors for each period of the time series (months or quarters)", 
                                                                               "Plots the raw series, the seasonal adjusted series and the trend", 
                                                                               "Plots the calendar effects, the seasonal component and the irregular"
                                                            )), class = "data.frame", row.names = c(NA, -10L))


kable(plot_methods, "latex", longtable = T,
      escape = FALSE, booktabs = T,
      caption = "Plots available with the \\pkg{RJDemetra} package.") %>%
  column_spec(1, width = "4cm") %>%
  column_spec(2, width = "4.5cm") %>%
  column_spec(3, width = "6cm")
```

## RegARIMA

The \code{regarima} object contains provided by the user model specification (\code{specification}; level 2 of the \code{sa_object}), the estimated coefficients for the ARIMA processes (\code{arima.coefficients}) and for the regressors (\code{regression.coefficients}), including ARMA orders (\code{arma}). The object includes also model quality measures (\code{loglik}), RegARIMA specification after its estimation with the estimated effects (e.g. linearized input series or outliers)(\code{model}), residuals of the RegARIMA model (\code{residuals}), several tests’ results for the residuals (\code{residuals.stat}) and finally the forecast of the pre-adjusted series (\code{forecasts}). All this information can be extracted individually by the user by referring to different parts of the S3 class object or for a predefined output functions \code{print()} or \code{summary()} can be used. Furthermore graphical presentations are also available with the function \code{plot()} that displays a set of graphs. For \code{regarima} by default the first six graphs are displayed, but specific ones can be chosen within the argument \code{which}. Table \ref{tab:plots_methods} summarizes all the graphs available for the \code{sa_object}, as well as its \code{plot()} options.

```{r}
sax13$regarima
summary(sax13$regarima)
plot(sax13$regarima, which = 2)
```

## Decomposition

As aforementioned the decomposition method differs between TRAMO-SEATS and X-13ARIMA, where SEATS is based on ARIMA-model and X-11-algorithm on linear filters. Consequently the composition of this object differs between the two methods (tables \ref{tab:obj_tab_x13} and \ref{tab:obj_tab_tramoseats}). The only common part is the first two sub-objects with the model specification (\code{specification}) and information on the decomposition mode (\code{mode}; e.g.: additive).

Then, the \code{decomposition_X11} object comprises quality measures on the decomposition (\code{mstats}), namely the $M$ and $Q$ statistics. It contains also the final unmodified S-I ratios $d8$ and final seasonal factors $d10$ (\code{si_ratio}), as well as the information on the final seasonal filter (\code{s_filter}) and trend filter(\code{t_filter}). The code below presents the output for X-11 decomposition:
```{r}
sax13$decomposition
```

As a reminder, in SEATS it is assumed that each component of the linearized series (received from TRAMO) is an outcome of a linear stochastic process and SEATS estimates an ARIMA model for each component (i.e. trend, seasonal, transitory and irregular). Therfore the \code{decomposition_SEATS} object contains the information on the estimated ARIMA models (\code{model}), the linearized components - as obtained from TRAMO (\code{linearized}) - and the theoretical components calculated from the ARIMA models (\code{components}). The code below presents the output for the SEATS decomposition, with the information on the ARIMA models:

```{r}
sats$decomposition
```

## Final
The final object has a simple structure as it includes the input series, final seasonally adjusted series and the final components (i.e. $t$ - trend-cycle, $s$ - seasonal component and $i$ - irregular component) (\code{series}), as well as their forecasts (\code{forecasts}). 
```{r}
sats$final
```

## Diagnostics
This part of the \code{sa_object} includes several diagnostics on the presence of seasonality in the input series and on the quality of the seasonal adjustment.

The tests for the seasonality presence (\code{combined_test}) are performed both on the entire series and in the last 3 years.

As regards the seasonal adjustment quality checks, they are grouped into two sets. The first looks at the contribution of each estimated component to the variance of the original series (\code{variance_decomposition}). The second verifies, with different tests, that there is no seasonal pattern left in the seasonally adjusted series and in the irregular component (\code{residuals_test}).

All the above checks (except \code{combined_seasonality_test}), together with a detailed description, are displayed when printing the diagnostics object.

```{r}
sats$diagnostics
```

## User-defined {#user-def}

As presented in the tables \ref{tab:obj_tab_x13} and \ref{tab:obj_tab_tramoseats} and in the previous sections the \code{sa_object} has a defined structure with a defined content. Nevertheless users can also extract additional output from the seasonal adjustment estimation and this will be stored under \code{user_defined} object in a form of a list.  In order to receive the additional output extra variables need to be defined as characters under the argument \code{userdefined} of the functions \code{x13()} or \code{tramoseats()}.

For example, to receive additionally tables $c10$ and $d16$  the following need to be specified in the function argument:

```{r}
sa_usrdef <- x13(myseries, spec = "RSA3", 
                 userdefined = c("decomposition.c10", "decomposition.d16"))
sa_usrdef$user_defined
```

The list of all available variables can be obtained with the following functions:

*  \code{user_defined_variables("X13-ARIMA")}
*  \code{user_defined_variables("TRAMO-SEATS")}


# Model specification: creation and modification {#user-def-spec}

Users can also create their own specifications by modifying pre-defined specifications (as described in tables \ref{tab:pre_def_ts} and \ref{tab:pre_def_x13}) or previously defined specifications or models. For that, there are two functions for each method (X-13ARIMA and TRAMO-SEATS) - one for the RegARIMA model and one for the entire seasonal adjustment: 

* RegARIMA model: \code{regarima_spec_x13()} for X-13ARIMA and \code{regarima_spec_tramoseats()} for TRAMO-SEATS;
* seasonal adjustment: \code{x13_spec()} for X-13ARIMA and \code{tramoseats_spec()} for TRAMO-SEATS.

As mentionned above, the input of the functions can be a pre-defined \proglang{JDemetra+} model specification, previously modified specification or a model.  

Once the specification is created, the estimations can be performed for: 

* RegARIMA model by \code{regarima()} and;
* seasonal adjustment with X-13ARIMA by \code{x13()} and with TRAMO-SEATS by \code{tramoseats()}.

The example below ilustrates how to create its own RegARIMA model for the TRAMO-SEATS method by adding an additive outlier in October 2009:

```{r}
regarima_ts_spec <- regarima_spec_tramoseats(spec = "TRfull",
             usrdef.outliersEnabled = TRUE,
             usrdef.outliersType = "AO",
             usrdef.outliersDate = "2009-10-01")
regarima_ts_model <- regarima(series = ipi_c_eu[, "EA19"],
                              spec = regarima_ts_spec)
regarima_ts_model
```

And how to modify the specification of the X-13ARIMA object \code{sa_usrdef} (defined in section \ref{user-def}) by changing the seasonal filter and performing a working day adjustment:
```{r}
sa_x13_spec <- x13_spec(spec = sa_usrdef,
                         tradingdays.option = "WorkingDays",
                         x11.seasonalma = "S3X3")
sa_x13_model <- x13(series = ipi_c_eu[, "EA19"],
                    spec = sa_x13_spec)
```

Almost all the specification variables available in \proglang{JDemetra+} can be used in \pkg{RJDemetra}. For more details see the help page for the corresponding function or the documentation of \proglang{JDemetra+}.

To prevent from wrong user specification, there are automatic checks in \pkg{RJDemetra}, like in \proglang{JDemetra+}. For example, to pre-specify an outlier or a user-defined variable you have to enable them (setting the parameter \code{usrdef.outliersEnabled} or \code{usrdef.varEnabled} to \code{TRUE}); or to fix the coefficient of an outlier or a user-defined regressor you have to specify the transformation function (\code{transform.function}, it cannot be automatic). Those checks are done each time a new specification is created. Therefore, some specifications cannot be set in two stages. For example, fixing the coefficient of an outlier has to be done at the same time when the outliers are defined. The following code doesn't fix the coefficient of the outlier previously defined for January 2001:

```{r}
regarima_wrong_spec <- regarima_spec_tramoseats(spec = regarima_ts_model,
             transform.function = "Log",
             usrdef.outliersCoef =  -0.8)
```

To fix it you have to re-define the outlier:
  
```{r}
regarima_good_spec <- regarima_spec_tramoseats(spec = regarima_ts_model,
             transform.function = "Log",
             usrdef.outliersType = "AO",
             usrdef.outliersDate = "2009-10-01",
             usrdef.outliersCoef =  -0.8)
```
The documentation for the functions used to modify specifications provide information on the interdependencies between different arguments. The package offers also functions to display different parts of the model specification. These are presented under the entry \code{specification} of the package documentation.  For instance, from the example above, we can check which user defined variables were enabled and with which parameters.

In the first case (wrongly specified), an outlier was pre-defined but its coefficient was not fixed: 

```{r}
s_usrdef(regarima_wrong_spec)
s_preOut(regarima_wrong_spec)
```

In the second case, the coefficient was correctly fixed: 
```{r}
s_usrdef(regarima_good_spec)
s_preOut(regarima_good_spec)
```

\hypertarget{manipulate-workspace}{%
\section[Manipulate JDemetra+ workspaces]{Manipulate \proglang{JDemetra+} workspaces}\label{manipulate-workspace}}


\pkg{RJDemetra} allows to interact with \proglang{JDemetra+} workspaces that can be opened by the software. A workspace includes:

- An XML file that enables users to import a workspace to \proglang{JDemetra+} and to display its content;  
- A folder containing several sub-folders that correspond to different types of items created by the user.

Each workspace can contain several multi-processings and each multi-processing stores results of the seasonal adjustment procedure performed with the TRAMO-SEATS or X-13ARIMA methods.

Exporting models to workspace allows to store easily the seasonal adjustment models, to change specifications with the \proglang{JDemetra+} graphical interface and to give models to users unfamiliar with \proglang{R}.

## Export a workspace {#export-wk}

Four functions can to be used to export models:

- \code{new_workspace()} to create a workspace;  
- \code{new_multiprocessing()} to create a multi-processing in a workspace;  
- \code{add_sa_item()} to add a seasonal adjustment model to a multi-processing;  
- \code{save_workspace()} to export the workspace.  

The following commands export seasonal adjustment models computed by TRAMO-SEATS and X-13ARIMA:

```{r}
myseries <- ipi_c_eu[, "EA19"]
sa_x13 <- x13(myseries)
sa_ts <- tramoseats(myseries)
```

First, to create a workspace and a multi-processing named "MP-1" the following need to be executed:
```{r}
wk <- new_workspace()
new_multiprocessing(wk, name = "MP-1")
```

Then, the two models will be added in the multiprocessing "MP1": the name of the seasonal adjustment model computed with X-13ARIMA will be "SA with X13" and the one with TRAMO-SEATS will be "SA with TramoSeats":

```{r}
add_sa_item(wk, multiprocessing = "MP-1",
            sa_obj = sa_x13, name =  "SA with X13")
add_sa_item(wk, multiprocessing =  "MP-1",
            sa_obj = sa_ts, name = "SA with TramoSeats")
```

The exported workspace is named "workspace.xml":
```{r}
dir <- tempdir()
save_workspace(wk, file =  file.path(dir, "workspace.xml"))
```


## Import a workspace

The following functions can be used to import a workspace: 

- \code{load_workspace()} to load a workspace;  
- \code{compute()} to compute multi-processings: by default a workspace contains only definitions, therfore computation is needed to get the seasonal adjustment model;  
- \code{get_model()} to get the seasonal adjustment models;  
- \code{get_ts()} to get the input raw time series,  \code{get_object()} and \code{get_all_objects} to navigate inside a workspace (extract a multi-processing or a seasonal adjustment model), \code{get_name()} to get names of the multiprocessings or the seasonal adjustment models, and \code{count()} to count the number of multiprocessings or seasonal adjustment models.

For instance, the following need to be run to import the workspace created in section \ref{export-wk} and to get the first multiprocessing and the first seasonal adjustment model:

```{r}
wk <- load_workspace(file =  file.path(dir, "workspace.xml"))
mp1 <- get_object(wk, 1)
sa_item1 <- get_object(mp1, 1)
```

To get the number of seasonal adjustment models in the multiprocessing:
```{r}
count(mp1)
```

And to receive the name of the first seasonal adjustment model in \proglang{JDemetra+}:
```{r}
get_name(sa_item1) 
```

Finally, raw time series and seasonal adjustment model can now be imported:
```{r}
raw_ts <- get_ts(sa_item1)
compute(wk)
sa_model1 <- get_model(sa_item1, workspace = wk)
```

\code{get_ts()} and \code{get_model()} can also be used directly on a workspace or on a multiprocessing to import all the raw time series or all the seasonal adjustment model:

- for a multiprocessing the result is a list which each element contains the information on the seasonal adjustment model;  
- for a workspace the result is a list of number of multi-processings length and which each element contains a list with the information on each seasonal adjustment model.

For example to get all raw time series of the workspace and all seasonal adjustment models of the first multi-processing the following need to be run:

```{r, eval=FALSE}
all_raw_ts <- get_ts(wk)
sa_models_of_mp1 <- get_model(mp1, workspace = wk)
```

The imports of seasonal adjustment models from a workspace work well when they have been created through \pkg{RJDemetra}. Troubles might occur when importing a workspace created with \proglang{JDemetra+}, in particular:

- Seasonal adjustment models with ramp effect or intervention variables will be partially imported: the result of the imported model will be correct but changing the specification (through \code{x13_spec()} or \code{tramoseats_spec()}) will erase them.  
- Seasonal adjustment models with no pre-processing (X-11 specification) are not supported: \code{NULL} object will be returned.  

# Advanced usage and examples

By default, \code{x13()}, \code{tramoseats()} and \code{regarima()} export a large number of diagnostics and indicators. This might be time-consuming, especially when dealing with many series and only a few indicators are needed. To customise the output and receive only the needed indicators, four functions extracting the associated seasonal adjustment Java model can be used: \code{jx13()}, \code{jtramoseats()}, \code{jregarima_x13()} and \code{jregarima_tramoseats()}. Three other functions can be used to manipulate these objects:

- \code{get_dictionary()} to get the list of indicators that can be extracted;  
- \code{get_indicators()} to get selected indicators;  
- \code{jSA2R()} to get the corresponding formatted seasonal adjustment or RegARIMA model.

For example to only receive the seasonally adjusted time series:

```{r}
sa_jx13 <- jx13(myseries)
head(get_dictionary(sa_jx13))
sa_series <- get_indicators(sa_jx13, "sa")
plot(sa_series[["sa"]])
```

To compute the revisions of the seasonal adjusted series of January 2010 with an automatic modelling:

```{r, cache=TRUE}
dates <- window(time(myseries), start = 2010)
revisions_history_j10 <- sapply(dates,function(last_date){
  sa_jx13 <- jx13(window(myseries, end = last_date))
  window(get_indicators(sa_jx13, "sa")[["sa"]],
         start = 2010,
         end = 2010)
})
revisions_history_j10 <- ts(revisions_history_j10,
                            start = 2010, frequency = 12)
plot(revisions_history_j10)
```

When performing seasonal adjustment on a large database, the most common error results from the preliminary check (used to verify the quality of the input series) when excluding highly problematic series (with too many identical observations and/or missing values). In this case, the \code{jx13()} function will not give an error but \code{get_indicators()} will only return a \code{NULL} objects:
```{r}
identical_ts <- ts(0,start = 2010, end = 2015, frequency = 12)
get_indicators(jx13(identical_ts), "sa", "sa_f")
```
To disable this preliminary check, you need to create a new specification with the parameter `preliminary.check = FALSE`:
```{r}
myspec <- x13_spec(preliminary.check = FALSE)
my_indicators <- get_indicators(jx13(identical_ts, myspec)
                                , "sa", "sa_f")
```

This might be useful when performing large scale seasonal adjustment. For example with our database on industrial production indices:
```{r, cache = TRUE}
ipi_sa_series <- lapply(colnames(ipi_c_eu),function(series){
  sa_jx13 <- jx13(ipi_c_eu[,series], myspec)
  get_indicators(sa_jx13, "sa")[["sa"]]
})
ipi_sa_series <- do.call(ts.union,ipi_sa_series)
colnames(ipi_sa_series) <- colnames(ipi_c_eu)
```


# Conclusion

\proglang{JDemetra+} is a powerful tool for seasonal and trading days adjustments. It implements the two leading methods, TRAMO-SEATS and X-13ARIMA, through a rich graphical interface. Besides seasonal adjustment, JDemetra+ bundles other time series models that are useful in the production or analysis of economic statistics, including for instance outlier detection, nowcasting, temporal disaggregation or benchmarking. It is also the only software officially recommended by Eurostat for seasonal and calendar adjustment.

Therefore, the package \pkg{RJDemetra}, being based on the same libraries of JDemetra+, uses certified and tested algorithms. It also offers huge opportunities to producers and researchers. Indeed, \proglang{JDemetra+} being widely used in production, it allows to:

- Easily create tools that can be used in production. For example \pkg{rjdqa} [@rjdqa] reproduces Statistics Canada dashboard, used to provide a snapshot snapshot of an single seasonal adjustment model at a point in time and to point out some possible problems.  
- Customize the outputs to the need of the producers of a specific institution. For example to goal of \pkg{persephone} [@persephone] is to have enable easy processing during production of seasonally adjusted series in Statistics Austria.  
- Extend the current \proglang{R} package to use the same seasonal adjustment methods used in production. For example \pkg{ggdemetra} [@ggdemetra] extend the \pkg{ggplot2} [@ggplot2] to add seasonal adjustment statistics to plots (diagnostics, outliers, ARIMA models, seasonally adjusted series, etc.).

Moreover, directly manipulate the Java objects makes \pkg{RJDemetra} much more performant than others \proglang{R} packages, specially with large scale seasonal adjustment or to conduct studies.

The package \pkg{RJDemetra} will also evolved with \proglang{JDemetra+} and integrate the new developments on seasonal adjustment methods, for example the future extension of the methods to series of all frequencies (weekly, daily, etc.).


# References {.unnumbered}


